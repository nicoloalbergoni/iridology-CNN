Una volta estratti i segmenti di iride dalle immagini originali dell’occhio si può passare alla fase di training. La vera e propria fase di training tuttavia necessita di due prerequisiti: la fase di preparazione dei dati e la fase di creazione del modello. Avviando lo script \texttt{train.py} la prima operazione che viene eseguita è quindi quella di preparazione dei dati, a tale scopo si invoca la funzione \texttt{create\_trainig\_data} presente nel file \texttt{data\_preparation.py} contenuto nel modulo \texttt{ML\_CNN}; in sostanza la funzione si occupa di strutturare i dati in modo tale che possano essere correttamente recepiti dalla rete neurale. Si parte caricando le immagini dei segmenti in memoria, già in fase di caricamento ad ogni immagine viene associata una label ovvero un identificatore che poi la rete utilizzerà per categorizzare le immagini. Si scorre quindi tra le immagini presenti nelle due sottocartelle di \texttt{TEMP\_SEG}  e per ogni immagine si crea un array contenente la matrice dei pixel che rappresenta l’immagine e la label di riferimento, in particolare se l’immagine proviene dalla sottocartella \texttt{DB\_NORMAL\_SEG} viene assegnata la label 0, ad indicare che il segmento non presenta problematiche, nel caso contrario invece si assegna la label 1. 

Ogni vettore matrice-label viene poi aggiunto in coda ad un altro vettore chiamato \texttt{training\_data}, tale vettore una volta finite le iterazioni conterrà tutte le coppie immagini-label. Successivamente su questo vettore si effettua uno shuffle ovvero si cambia l’ordine dei vari elementi interni;  ciò risulta molto utile nella fase training in quanto in questo modo la rete evita di imparare eventuali pattern nella distribuzione dei dati stessi e quindi si evita l’introduzione di una possibile distorsione nella previsione finale. Dopo lo shuffle si procede alla creazione di due particolari vettori:

\begin{itemize}
  \item \textbf{Features}: le features sono le variabili indipendenti che agiscono come input del modello. Il modello impara dalle features per poi fare le previsioni
  \item \textbf{Labels}: le labels rappresentano l’output finale, le classi in cui categorizzare le immagini
\end{itemize}

Nel caso d’uso, il vettore delle features, comunemente chiamato \texttt{X}, contiene tutte le matrici di pixel (ovvero le immagini) presenti nell’array \texttt{training\_data}, mentre il vettore delle labels, detto \texttt{y}, contiene i valori di categorizzazione (0 o 1) associati ad ogni immagine. In sostanza quello che accade è che partendo dall’array \texttt{training\_data} si separano le immagini dalle label, la corrispondenza segmento-label viene mantenuta tramite l’indice di posizione nei rispettivi array. 

L’ultimo passaggio da fare prima di poter ottenere i dati nel formato corretto è quello di reshape dell’array \texttt{X} (array di feature). Tale passaggio è necessario in quanto il modello si aspetta un dataset di input della forma (numero di immagini, height dell’immagine, width dell’immagine, numero di canali dell’immagine), si effettua quindi un ridimensionamento, tramite la funzione \texttt{reshape} della libreria NumPy, sull’array \texttt{X} passando come ultimo parametro il valore 1 che sta ad indicare che si lavora con immagini a singolo canale, quindi grayscale. Dopo quest’ultimo passaggio si hanno i dati strutturati nella forma corretta per il training, i vettori necessari sono quindi \texttt{X} (features) e \texttt{y} (labels).

L’utente può inoltre, a sua scelta, abilitare il parametro \texttt{SAVE\_TRAIN\_DATA} nella sezione \texttt{NEURAL\_NETWORK\_TRAIN} per effettuare il salvataggio su disco dei vettori \texttt{X} e \texttt{y} in modo da poterli riutilizzare in futuro, ad esempio per fare training su reti diverse. Il salvataggio avviene grazie al modulo pickle (nativo in python 3) che si occupa di serializzare oggetti python in vettori di caratteri. I file risultanti dall serializzazione sono \texttt{X.pickle} e \texttt{y.pickle}. Per il training del modello vengono comunque utilizzati gli ultimi vettori di \texttt{X} e \texttt{y} prodotti.
